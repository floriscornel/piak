import { expect, test } from "vitest";
import {
	type Input as FlattenInput,
	type Output as FlattenOutput,
	flatten,
} from "./flattenProperties";

/**
 * The input will be a nested object of properties
 * The output will be a flattened object of properties where references have their refID set
 */
test("flatten properties", () => {
	const input: FlattenInput = {
		GetTagList: {
			type: "object",
			propertyID: 1,
			properties: {
				posts: {
					type: "array",
					items: {
						type: "object",
						propertyID: 2,
						properties: {
							id: {
								type: "string",
								format: "uuid",
							},
							title: {
								type: "string",
							},
							content: {
								type: "string",
							},
						},
					},
				},
			},
		},
	};

	const expectedOutput: FlattenOutput = {
		GetTagList: {
			type: "object",
			propertyID: 1,
			properties: {
				posts: {
					type: "array",
					items: {
						type: "reference", // The nested object is replaced with a reference
						refID: 2,
					},
				},
			},
		},
		// The nested object is added to the top level
		// The name of the object is generated by the converter
		PostsItem: {
			propertyID: 2,
			type: "object",
			properties: {
				id: { type: "string", format: "uuid" },
				title: { type: "string" },
				content: { type: "string" },
			},
		},
	};

	const output = flatten(input);

	expect(output).toEqual(expectedOutput);
});
