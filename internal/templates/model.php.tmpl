<?php
{{- if .Config.PHP.UseStrictTypes }}

declare(strict_types=1);
{{- end }}
{{- if .Config.PHP.Namespace }}

namespace {{ .Config.PHP.Namespace }};
{{- end }}

{{- /* Import statements will be generated automatically when needed */ -}}

{{- if .Config.PHP.GenerateDocblocks }}

/**
{{- if .Description }}
 * {{ .Description }}
{{- else }}
 * {{ .Name }} model
{{- end }}
{{- if .SpecialCases }}
 *
 * Special patterns supported:
{{- range .SpecialCases }}
{{- if eq . 1 }}
 * - Discriminated Union
{{- else if eq . 2 }}
 * - Polymorphic Array
{{- else if eq . 3 }}
 * - Dynamic Properties
{{- else if eq . 4 }}
 * - Ambiguous Union
{{- else if eq . 10 }}
 * - Union Types
{{- end }}
{{- end }}
{{- end }}
 * 
 * Generated by piak from OpenAPI specification
 */
{{- end }}
readonly class {{ .Name }}
{
{{- /* Handle discriminated unions */ -}}
{{- if hasSpecialCase . 1 }}
{{- if .TemplateContext.Discriminator }}
{{- $discriminator := .TemplateContext.Discriminator }}

    /**
     * Discriminator field for union type resolution
     */
    public readonly string ${{ $discriminator.PropertyName }};
{{- end }}
{{- end }}

{{- /* Constructor with property promotion */ -}}
    public function __construct(
{{- range $index, $prop := .Properties }}
{{- if $.Config.PHP.GenerateDocblocks }}
{{- if $prop.PHPType.IsArray }}
        /** @var {{ formatPHPDocType $prop.PHPType }} */
{{- end }}
{{- end }}
        public {{ formatPHPType $prop.PHPType }} ${{ $prop.Name | toCamel }}{{ if not $prop.Required }}{{ if $prop.DefaultValue }} = {{ formatDefaultValue $prop.DefaultValue }}{{ else if $prop.PHPType.IsArray }} = []{{ else }} = null{{ end }}{{ end }}{{ if ne $index (sub (len $.Properties) 1) }},{{ end }}
{{- end }}
    ) {}

{{- /* Handle dynamic properties for additionalProperties pattern */ -}}
{{- if hasSpecialCase . 3 }}
{{- if .TemplateContext.DynamicProperties }}
{{- $dynProps := .TemplateContext.DynamicProperties }}

    /**
     * Additional properties beyond the defined schema
{{- if $dynProps.AdditionalProperties }}
     * @var array<string, {{ formatPHPDocType $dynProps.AdditionalProperties.PHPType }}>
{{- else }}
     * @var array<string, mixed>
{{- end }}
     */
    private array $additionalProperties = [];

    /**
     * Get additional property value
     */
    public function getAdditionalProperty(string $name): mixed
    {
        return $this->additionalProperties[$name] ?? null;
    }

    /**
     * Set additional property value
     */
    public function setAdditionalProperty(string $name, mixed $value): self
    {
{{- if .TemplateContext.DynamicProperties.AdditionalProperties }}
        // Type validation for additional properties
        // TODO: Add type validation based on schema
{{- end }}
        $this->additionalProperties[$name] = $value;
        return $this;
    }

    /**
     * Get all additional properties
     * @return array<string, mixed>
     */
    public function getAdditionalProperties(): array
    {
        return $this->additionalProperties;
    }
{{- end }}
{{- end }}

{{- /* Generate fromArray factory method for complex patterns */ -}}

    /**
     * Create instance from array data
     * @param array<string, mixed> $data
     * @return self
     * @throws \InvalidArgumentException
     */
    public static function fromArray(array $data): self
    {
{{- /* Add validation for required fields */ -}}
{{- range .Properties }}
{{- if .Required }}
        if (!isset($data['{{ .Name }}']){{ if eq .PHPType.Name "string" }} || !is_string($data['{{ .Name }}']){{ else if eq .PHPType.Name "int" }} || (!is_int($data['{{ .Name }}']) && !is_numeric($data['{{ .Name }}'])){{ else if eq .PHPType.Name "bool" }} || !is_bool($data['{{ .Name }}']){{ else if .PHPType.IsArray }} || !is_array($data['{{ .Name }}']){{ end }}) {
            throw new \InvalidArgumentException('{{ $.Name }} {{ .Name }} must be a {{ .PHPType.Name }}');
        }
{{- end }}
{{- end }}

{{- /* Process array properties with type validation */ -}}
{{- range .Properties }}
{{- if .PHPType.IsArray }}
{{- if .Required }}
        // Process {{ .Name }} array
        ${{ .Name | toCamel }} = [];
        foreach ($data['{{ .Name }}'] as ${{ .Name | singularize }}) {
{{- if .PHPType.ArrayItemType }}
{{- if eq .PHPType.ArrayItemType.Name "string" }}
            if (!is_string(${{ .Name | singularize }})) {
                throw new \InvalidArgumentException('{{ .Name | toCamel | singularize }} must be a string');
            }
            ${{ .Name | toCamel }}[] = ${{ .Name | singularize }};
{{- else if ne .PHPType.ArrayItemType.Name "mixed" }}
            if (!is_array(${{ .Name | singularize }})) {
                throw new \InvalidArgumentException('{{ .Name | toCamel | singularize }} data must be an array');
            }
            /** @var array<string, mixed> ${{ .Name | singularize }}Data */
            ${{ .Name | singularize }}Data = ${{ .Name | singularize }};
            ${{ .Name | toCamel }}[] = {{ .PHPType.ArrayItemType.Name }}::fromArray(${{ .Name | singularize }}Data);
{{- else }}
            ${{ .Name | toCamel }}[] = ${{ .Name | singularize }};
{{- end }}
{{- else }}
            ${{ .Name | toCamel }}[] = ${{ .Name | singularize }};
{{- end }}
        }

{{- else }}
        // Process {{ .Name }} array if present
        ${{ .Name | toCamel }} = [];
        if (isset($data['{{ .Name }}']) && is_array($data['{{ .Name }}'])) {
            foreach ($data['{{ .Name }}'] as ${{ .Name | singularize }}) {
{{- if .PHPType.ArrayItemType }}
{{- if eq .PHPType.ArrayItemType.Name "string" }}
                if (!is_string(${{ .Name | singularize }})) {
                    throw new \InvalidArgumentException('{{ .Name | toCamel | singularize }} must be a string');
                }
                ${{ .Name | toCamel }}[] = ${{ .Name | singularize }};
{{- else if ne .PHPType.ArrayItemType.Name "mixed" }}
                if (!is_array(${{ .Name | singularize }})) {
                    throw new \InvalidArgumentException('{{ .Name | toCamel | singularize }} data must be an array');
                }
                /** @var array<string, mixed> ${{ .Name | singularize }}Data */
                ${{ .Name | singularize }}Data = ${{ .Name | singularize }};
                ${{ .Name | toCamel }}[] = {{ .PHPType.ArrayItemType.Name }}::fromArray(${{ .Name | singularize }}Data);
{{- else }}
                ${{ .Name | toCamel }}[] = ${{ .Name | singularize }};
{{- end }}
{{- else }}
                ${{ .Name | toCamel }}[] = ${{ .Name | singularize }};
{{- end }}
            }
        }

{{- end }}
{{- else if and (not .Required) (ne .PHPType.Name "string") (ne .PHPType.Name "int") (ne .PHPType.Name "bool") }}
        // Process {{ .Name }} if present
        ${{ .Name | toCamel }} = null;
        if (isset($data['{{ .Name }}']) && is_array($data['{{ .Name }}'])) {
            /** @var array<string, mixed> ${{ .Name }}Data */
            ${{ .Name }}Data = $data['{{ .Name }}'];
            ${{ .Name | toCamel }} = {{ .PHPType.Name }}::fromArray(${{ .Name }}Data);
        }

{{- end }}
{{- end }}

        return new self(
{{- range $index, $prop := .Properties }}
            {{ $prop.Name | toCamel }}: {{ if $prop.PHPType.IsArray }}${{ $prop.Name | toCamel }}{{ else if $prop.Required }}$data['{{ $prop.Name }}']{{ else if eq $prop.PHPType.Name "int" }}isset($data['{{ $prop.Name }}']) && (is_int($data['{{ $prop.Name }}']) || is_numeric($data['{{ $prop.Name }}'])) ? (int) $data['{{ $prop.Name }}'] : null{{ else if eq $prop.PHPType.Name "string" }}isset($data['{{ $prop.Name }}']) && is_string($data['{{ $prop.Name }}']) ? $data['{{ $prop.Name }}'] : null{{ else if eq $prop.PHPType.Name "bool" }}isset($data['{{ $prop.Name }}']) && is_bool($data['{{ $prop.Name }}']) ? $data['{{ $prop.Name }}'] : null{{ else }}${{ $prop.Name | toCamel }}{{ end }}{{ if ne $index (sub (len $.Properties) 1) }},{{ end }}
{{- end }}
        );
    }

{{- /* Union type helper methods */ -}}
{{- if hasSpecialCase . 10 }}
{{- if .TemplateContext.UnionType }}
{{- $unionCtx := .TemplateContext.UnionType }}

    /**
     * Detect and create appropriate union type instance
     * @param array<string, mixed> $data
     * @return self
     */
    public static function fromUnionData(array $data): self
    {
{{ renderUnionTypeDetection $unionCtx | indent 8 }}
    }
{{- end }}
{{- end }}

{{- /* Enum helper methods */ -}}
{{- if .IsEnum }}

    /**
     * Get all possible enum values
     * @return array<mixed>
     */
    public static function getAllowedValues(): array
    {
        return [
{{- range .EnumValues }}
            {{ formatDefaultValue . }},
{{- end }}
        ];
    }

    /**
     * Check if value is valid enum value
     */
    public static function isValidValue(mixed $value): bool
    {
        return in_array($value, self::getAllowedValues(), true);
    }
{{- end }}

{{- /* Custom methods defined in the model */ -}}
{{- range .Methods }}

    /**
     * {{ .DocComment }}
     */
    {{ .Visibility }}{{ if .IsStatic }} static{{ end }} function {{ .Name }}(
{{- range $index, $param := .Parameters }}
        {{ formatConstructorParam $param (eq $index (sub (len $.Parameters) 1)) }}
{{- end }}
    ){{ if .ReturnType }}: {{ .ReturnType }}{{ end }}
    {
{{ .Body | indent 8 }}
    }
{{- end }}
} 