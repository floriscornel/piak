<?php
{{- if .Config.PHP.UseStrictTypes }}

declare(strict_types=1);
{{- end }}
{{- if .Config.PHP.Namespace }}

namespace {{ .Config.PHP.Namespace }};
{{- end }}

{{- /* Generate import statements for complex types */ -}}
{{- $imports := slice }}
{{- range .Properties }}
  {{- $imports = append $imports .PHPType.ImportStatements }}
{{- end }}
{{- if $imports }}

{{ generateUseStatements $imports }}
{{- end }}

{{- if .Config.PHP.GenerateDocblocks }}

/**
{{- if .Description }}
 * {{ .Description }}
{{- else }}
 * {{ .Name }} model
{{- end }}
{{- if .SpecialCases }}
 *
 * Special patterns supported:
{{- range .SpecialCases }}
{{- if eq . 1 }}
 * - Discriminated Union
{{- else if eq . 2 }}
 * - Polymorphic Array
{{- else if eq . 3 }}
 * - Dynamic Properties
{{- else if eq . 4 }}
 * - Ambiguous Union
{{- else if eq . 10 }}
 * - Union Types
{{- end }}
{{- end }}
{{- end }}
 * 
 * Generated by piak from OpenAPI specification
 */
{{- end }}
{{- if .Config.PHP.UseReadonlyProps }}readonly {{ end }}class {{ .Name }}
{
{{- /* Handle discriminated unions */ -}}
{{- if hasSpecialCase . 1 }}
{{- if .TemplateContext.Discriminator }}
{{- $discriminator := .TemplateContext.Discriminator }}

    /**
     * Discriminator field for union type resolution
     */
    public readonly string ${{ $discriminator.PropertyName }};
{{- end }}
{{- end }}

{{- /* Generate properties */ -}}
{{- range .Properties }}
{{- if $.Config.PHP.GenerateDocblocks }}

    /**
{{- if .Description }}
     * {{ .Description }}
{{- end }}
     * @var {{ formatPHPDocType .PHPType }}
     */
{{- end }}
    {{- if $.Config.PHP.UseReadonlyProps }}readonly {{ end }}{{ if not .Required }}?{{ end }}{{ formatPHPType .PHPType }} ${{ .Name | toSnake }};
{{- end }}

{{- /* Handle dynamic properties for additionalProperties pattern */ -}}
{{- if hasSpecialCase . 3 }}
{{- if .TemplateContext.DynamicProperties }}
{{- $dynProps := .TemplateContext.DynamicProperties }}

    /**
     * Additional properties beyond the defined schema
{{- if $dynProps.AdditionalProperties }}
     * @var array<string, {{ formatPHPDocType $dynProps.AdditionalProperties.PHPType }}>
{{- else }}
     * @var array<string, mixed>
{{- end }}
     */
    private array $additionalProperties = [];
{{- end }}
{{- end }}

{{- /* Constructor */ -}}
{{- if .Properties }}

    public function __construct(
{{- range $index, $prop := .Properties }}
        {{ formatConstructorParam $prop (eq $index (sub (len $.Properties) 1)) }}
{{- end }}
    ) {
{{- range .Properties }}
        $this->{{ .Name | toSnake }} = ${{ .Name | toSnake }};
{{- end }}
    }
{{- end }}

{{- /* Generate fromArray factory method for complex patterns */ -}}
{{- if .Config.PHP.GenerateFromArray }}

    /**
     * Create instance from array data
     * @param array<string, mixed> $data
     * @return self
     * @throws \InvalidArgumentException
     */
    {{ renderFromArrayMethod . | indent 4 }}
{{- end }}

{{- /* Generate getters and setters */ -}}
{{- range .Properties }}

    public function get{{ .Name | toCamel }}(): {{ if not .Required }}?{{ end }}{{ formatPHPType .PHPType }}
    {
        return $this->{{ .Name | toSnake }};
    }

    public function set{{ .Name | toCamel }}({{ if not .Required }}?{{ end }}{{ formatPHPType .PHPType }} ${{ .Name | toSnake }}): self
    {
{{- if .ValidationRules }}
        // Validation
{{ renderPropertyValidation .ValidationRules | indent 8 }}
{{- end }}
        $this->{{ .Name | toSnake }} = ${{ .Name | toSnake }};
        return $this;
    }
{{- end }}

{{- /* Additional methods for dynamic properties */ -}}
{{- if hasSpecialCase . 3 }}

    /**
     * Get additional property value
     */
    public function getAdditionalProperty(string $name): mixed
    {
        return $this->additionalProperties[$name] ?? null;
    }

    /**
     * Set additional property value
     */
    public function setAdditionalProperty(string $name, mixed $value): self
    {
{{- if .TemplateContext.DynamicProperties.AdditionalProperties }}
        // Type validation for additional properties
        // TODO: Add type validation based on schema
{{- end }}
        $this->additionalProperties[$name] = $value;
        return $this;
    }

    /**
     * Get all additional properties
     * @return array<string, mixed>
     */
    public function getAdditionalProperties(): array
    {
        return $this->additionalProperties;
    }
{{- end }}

{{- /* Union type helper methods */ -}}
{{- if hasSpecialCase . 10 }}
{{- if .TemplateContext.UnionType }}
{{- $unionCtx := .TemplateContext.UnionType }}

    /**
     * Detect and create appropriate union type instance
     * @param array<string, mixed> $data
     * @return self
     */
    public static function fromUnionData(array $data): self
    {
{{ renderUnionTypeDetection $unionCtx | indent 8 }}
    }
{{- end }}
{{- end }}

{{- /* Enum helper methods */ -}}
{{- if .IsEnum }}

    /**
     * Get all possible enum values
     * @return array<mixed>
     */
    public static function getAllowedValues(): array
    {
        return [
{{- range .EnumValues }}
            {{ formatDefaultValue . }},
{{- end }}
        ];
    }

    /**
     * Check if value is valid enum value
     */
    public static function isValidValue(mixed $value): bool
    {
        return in_array($value, self::getAllowedValues(), true);
    }
{{- end }}

{{- /* Custom methods defined in the model */ -}}
{{- range .Methods }}

    /**
     * {{ .DocComment }}
     */
    {{ .Visibility }}{{ if .IsStatic }} static{{ end }} function {{ .Name }}(
{{- range $index, $param := .Parameters }}
        {{ formatConstructorParam $param (eq $index (sub (len $.Parameters) 1)) }}
{{- end }}
    ){{ if .ReturnType }}: {{ .ReturnType }}{{ end }}
    {
{{ .Body | indent 8 }}
    }
{{- end }}
} 