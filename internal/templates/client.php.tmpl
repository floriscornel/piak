<?php
{{- if .Config.PHP.UseStrictTypes }}

declare(strict_types=1);
{{- end }}
{{- if .Config.PHP.Namespace }}

namespace {{ .Config.PHP.Namespace }};
{{- end }}

{{- /* Generate HTTP client imports */ -}}
{{- $clientImports := getHTTPClientImports .Config.HTTPClient }}
{{- if $clientImports }}

{{ generateUseStatements $clientImports }}
{{- end }}

{{- /* Model imports will be generated automatically when needed */ -}}
{{- if .Config.PHP.GenerateDocblocks }}

/**
 * {{ .Info.Title }} API Client
 * 
 * {{ .Info.Description }}
 * Version: {{ .Info.Version }}
 * 
 * HTTP Client: {{ .Config.HTTPClient }}
 * 
 * Generated by piak from OpenAPI specification
 */
{{- end }}
class ApiClient
{
{{- if eq .Config.HTTPClient "guzzle" }}
    private Client $client;
{{- else if eq .Config.HTTPClient "laravel" }}
    private HttpFactory $http;
{{- end }}
    private string $baseUrl;
    private array $defaultHeaders;
    private array $defaultOptions;

    public function __construct(
        string $baseUrl,
        array $defaultHeaders = [],
        array $defaultOptions = []
{{- if eq .Config.HTTPClient "guzzle" }}
        ,?Client $client = null
{{- else if eq .Config.HTTPClient "laravel" }}
        ,?HttpFactory $http = null
{{- end }}
    ) {
        $this->baseUrl = rtrim($baseUrl, '/');
        $this->defaultHeaders = array_merge([
            'Accept' => 'application/json',
            'Content-Type' => 'application/json',
        ], $defaultHeaders);
        $this->defaultOptions = $defaultOptions;
        
{{- if eq .Config.HTTPClient "guzzle" }}
        $this->client = $client ?? new Client();
{{- else if eq .Config.HTTPClient "laravel" }}
        $this->http = $http ?? app(HttpFactory::class);
{{- end }}
    }

{{- range .Endpoints }}

{{- if $.Config.PHP.GenerateDocblocks }}
    /**
{{- if .Description }}
     * {{ .Description }}
{{- else if .Summary }}
     * {{ .Summary }}
{{- end }}
     *
{{- range .Parameters }}
     * @param {{ formatPHPDocType .Schema.PHPType }} ${{ .Name | toSnake }}{{ if .Description }} {{ .Description }}{{ end }}
{{- end }}
{{- if .RequestBody }}
     * @param {{ .RequestBody.Schema.Name }} $requestBody{{ if .RequestBody.Description }} {{ .RequestBody.Description }}{{ end }}
{{- end }}
{{- if .Responses }}
{{- $primaryResponse := index .Responses 0 }}
{{- if $primaryResponse.Schema }}
     * @return {{ $primaryResponse.Schema.Name }}
{{- else }}
     * @return array<string, mixed>
{{- end }}
{{- else }}
     * @return array<string, mixed>
{{- end }}
{{- if eq $.Config.HTTPClient "guzzle" }}
     * @throws GuzzleException
{{- end }}
     * @throws \InvalidArgumentException
     * @throws \Exception
     */
{{- end }}
    public function {{ .MethodName | toLower }}(
{{- range $index, $param := .Parameters }}
        {{ formatConstructorParam $param (eq $index (sub (len .Parameters) 1)) }}
{{- end }}
{{- if .RequestBody }}
        ,{{ .RequestBody.Schema.Name }} $requestBody
{{- end }}
    ){{ if .Responses }}{{ $primaryResponse := index .Responses 0 }}{{ if $primaryResponse.Schema }}: {{ $primaryResponse.Schema.Name }}{{ else }}: array{{ end }}{{ else }}: array{{ end }}
    {
        $url = $this->baseUrl . '{{ .Path }}';
        
{{- /* Handle path parameters */ -}}
{{- range .Parameters }}
{{- if eq .In "path" }}
        $url = str_replace('{{ "{" }}{{ .Name }}{{ "}" }}', (string) ${{ .Name | toSnake }}, $url);
{{- end }}
{{- end }}

{{- /* Build query parameters */ -}}
{{- $hasQueryParams := false }}
{{- range .Parameters }}
{{- if eq .In "query" }}
{{- if not $hasQueryParams }}
        $queryParams = [];
{{- $hasQueryParams = true }}
{{- end }}
        if (isset(${{ .Name | toSnake }})) {
            $queryParams['{{ .Name }}'] = ${{ .Name | toSnake }};
        }
{{- end }}
{{- end }}

{{- /* Build headers */ -}}
{{- $hasHeaderParams := false }}
{{- range .Parameters }}
{{- if eq .In "header" }}
{{- if not $hasHeaderParams }}
        $headers = $this->defaultHeaders;
{{- $hasHeaderParams = true }}
{{- end }}
        if (isset(${{ .Name | toSnake }})) {
            $headers['{{ .Name }}'] = ${{ .Name | toSnake }};
        }
{{- end }}
{{- end }}
{{- if not $hasHeaderParams }}
        $headers = $this->defaultHeaders;
{{- end }}

{{- if eq $.Config.HTTPClient "guzzle" }}
        $options = array_merge($this->defaultOptions, [
            'headers' => $headers,
{{- if .RequestBody }}
            'json' => $requestBody,
{{- end }}
{{- if $hasQueryParams }}
            'query' => $queryParams,
{{- end }}
        ]);

        $response = $this->client->request('{{ .Method | toUpper }}', $url, $options);
        $data = json_decode($response->getBody()->getContents(), true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \Exception('Failed to decode JSON response: ' . json_last_error_msg());
        }
{{- else if eq $.Config.HTTPClient "laravel" }}
        $request = $this->http->withHeaders($headers);
        
{{- if $hasQueryParams }}
        $request = $request->withQuery($queryParams);
{{- end }}
        
{{- if .RequestBody }}
        $response = $request->{{ .Method | toLower }}($url, $requestBody);
{{- else }}
        $response = $request->{{ .Method | toLower }}($url);
{{- end }}
        
        if (!$response->successful()) {
            throw new \Exception('HTTP request failed with status: ' . $response->status());
        }
        
        $data = $response->json();
{{- else if eq $.Config.HTTPClient "curl" }}
        // cURL implementation
        $ch = curl_init();
        
        curl_setopt_array($ch, [
            CURLOPT_URL => $url{{ if $hasQueryParams }} . '?' . http_build_query($queryParams){{ end }},
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_CUSTOMREQUEST => '{{ .Method | toUpper }}',
            CURLOPT_HTTPHEADER => array_map(
                fn($key, $value) => "$key: $value",
                array_keys($headers),
                array_values($headers)
            ),
{{- if .RequestBody }}
            CURLOPT_POSTFIELDS => json_encode($requestBody),
{{- end }}
        ]);
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $error = curl_error($ch);
        curl_close($ch);
        
        if ($error) {
            throw new \Exception('cURL error: ' . $error);
        }
        
        if ($httpCode >= 400) {
            throw new \Exception('HTTP request failed with status: ' . $httpCode);
        }
        
        $data = json_decode($response, true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \Exception('Failed to decode JSON response: ' . json_last_error_msg());
        }
{{- end }}

{{- if .Responses }}
{{- $primaryResponse := index .Responses 0 }}
{{- if $primaryResponse.Schema }}
        return {{ $primaryResponse.Schema.Name }}::fromArray($data);
{{- else }}
        return $data;
{{- end }}
{{- else }}
        return $data;
{{- end }}
    }
{{- end }}

    /**
     * Make a generic HTTP request
     * 
     * @param string $method HTTP method
     * @param string $endpoint API endpoint
     * @param array<string, mixed> $data Request data
     * @param array<string, string> $headers Additional headers
     * @return array<string, mixed>
{{- if eq .Config.HTTPClient "guzzle" }}
     * @throws GuzzleException
{{- end }}
     * @throws \Exception
     */
    public function request(
        string $method,
        string $endpoint,
        array $data = [],
        array $headers = []
    ): array {
        $url = $this->baseUrl . '/' . ltrim($endpoint, '/');
        $allHeaders = array_merge($this->defaultHeaders, $headers);
        
{{- if eq .Config.HTTPClient "guzzle" }}
        $options = array_merge($this->defaultOptions, [
            'headers' => $allHeaders,
        ]);
        
        if (!empty($data)) {
            if (in_array(strtoupper($method), ['GET', 'DELETE'])) {
                $options['query'] = $data;
            } else {
                $options['json'] = $data;
            }
        }
        
        $response = $this->client->request($method, $url, $options);
        $responseData = json_decode($response->getBody()->getContents(), true);
{{- else if eq .Config.HTTPClient "laravel" }}
        $request = $this->http->withHeaders($allHeaders);
        
        if (in_array(strtoupper($method), ['GET', 'DELETE']) && !empty($data)) {
            $request = $request->withQuery($data);
            $response = $request->{strtolower($method)}($url);
        } else {
            $response = $request->{strtolower($method)}($url, $data);
        }
        
        if (!$response->successful()) {
            throw new \Exception('HTTP request failed with status: ' . $response->status());
        }
        
        $responseData = $response->json();
{{- else if eq .Config.HTTPClient "curl" }}
        $ch = curl_init();
        
        $curlOptions = [
            CURLOPT_URL => $url,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_CUSTOMREQUEST => strtoupper($method),
            CURLOPT_HTTPHEADER => array_map(
                fn($key, $value) => "$key: $value",
                array_keys($allHeaders),
                array_values($allHeaders)
            ),
        ];
        
        if (!empty($data)) {
            if (in_array(strtoupper($method), ['GET', 'DELETE'])) {
                $curlOptions[CURLOPT_URL] .= '?' . http_build_query($data);
            } else {
                $curlOptions[CURLOPT_POSTFIELDS] = json_encode($data);
            }
        }
        
        curl_setopt_array($ch, $curlOptions);
        
        $response = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $error = curl_error($ch);
        curl_close($ch);
        
        if ($error) {
            throw new \Exception('cURL error: ' . $error);
        }
        
        if ($httpCode >= 400) {
            throw new \Exception('HTTP request failed with status: ' . $httpCode);
        }
        
        $responseData = json_decode($response, true);
{{- end }}
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new \Exception('Failed to decode JSON response: ' . json_last_error_msg());
        }
        
        return $responseData;
    }
} 