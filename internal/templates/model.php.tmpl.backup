<?php
{{- if .Config.PHP.UseStrictTypes }}

declare(strict_types=1);
{{- end }}
{{- if .Config.PHP.Namespace }}

namespace {{ .Config.PHP.Namespace }};
{{- end }}

{{- /* Import statements will be generated automatically when needed */ -}}

{{- if .Config.PHP.GenerateDocblocks }}

/**
{{- if .Description }}
 * {{ .Description }}
{{- else }}
 * {{ .Name }} model
{{- end }}
{{- if .SpecialCases }}
 *
 * Special patterns supported:
{{- range .SpecialCases }}
{{- if eq . 1 }}
 * - Discriminated Union
{{- else if eq . 2 }}
 * - Polymorphic Array
{{- else if eq . 3 }}
 * - Dynamic Properties
{{- else if eq . 4 }}
 * - Ambiguous Union
{{- else if eq . 10 }}
 * - Union Types
{{- end }}
{{- end }}
{{- end }}
 * 
 * Generated by piak from OpenAPI specification
 */
{{- end }}
readonly class {{ .Name }}
{
{{- /* Handle discriminated unions */ -}}
{{- if hasSpecialCase . 1 }}
{{- if .TemplateContext.Discriminator }}
{{- $discriminator := .TemplateContext.Discriminator }}

    /**
     * Discriminator field for union type resolution
     */
    public readonly string ${{ $discriminator.PropertyName }};
{{- end }}
{{- end }}

    public function __construct(
{{- range $index, $prop := .Properties }}
{{- if $.Config.PHP.GenerateDocblocks }}
{{- if $prop.PHPType.IsArray }}
        /** @var {{ formatPHPDocType $prop.PHPType }} */
{{- end }}
{{- end }}
        public {{ formatPHPType $prop.PHPType }} ${{ $prop.Name | toCamelCase }}{{ if not $prop.Required }}{{ if $prop.DefaultValue }} = {{ formatDefaultValue $prop.DefaultValue }}{{ else if $prop.PHPType.IsArray }} = []{{ else }} = null{{ end }}{{ end }}{{ if ne $index (sub (len $.Properties) 1) }},{{ end }}
{{- end }}
    ) {}

{{- /* Handle dynamic properties for additionalProperties pattern */ -}}
{{- if hasSpecialCase . 3 }}
{{- if .TemplateContext.DynamicProperties }}
{{- $dynProps := .TemplateContext.DynamicProperties }}

    /**
     * Additional properties beyond the defined schema
{{- if $dynProps.AdditionalProperties }}
     * @var array<string, {{ formatPHPDocType $dynProps.AdditionalProperties.PHPType }}>
{{- else }}
     * @var array<string, mixed>
{{- end }}
     */
    private array $additionalProperties = [];

    /**
     * Get additional property value
     */
    public function getAdditionalProperty(string $name): mixed
    {
        return $this->additionalProperties[$name] ?? null;
    }

    /**
     * Set additional property value
     */
    public function setAdditionalProperty(string $name, mixed $value): self
    {
{{- if .TemplateContext.DynamicProperties.AdditionalProperties }}
        // Type validation for additional properties
        // TODO: Add type validation based on schema
{{- end }}
        $this->additionalProperties[$name] = $value;
        return $this;
    }

    /**
     * Get all additional properties
     * @return array<string, mixed>
     */
    public function getAdditionalProperties(): array
    {
        return $this->additionalProperties;
    }
{{- end }}
{{- end }}

    /**
     * Create instance from array data
     * @param array<string, mixed> $data
     * @return self
     * @throws \InvalidArgumentException
     */
    public static function fromArray(array $data): self
    {
{{- /* Handle required fields with modern validation */ -}}
{{- range .Properties }}
{{- if .Required }}
        // Required fields with validation
        ${{ .Name | toCamelCase }} = $data['{{ .Name }}'] ?? throw new \InvalidArgumentException('{{ $.Name }} {{ .Name }} is required');
{{- if eq .PHPType.Name "string" }}
        if (!is_string(${{ .Name | toCamelCase }})) {
            throw new \InvalidArgumentException('{{ $.Name }} {{ .Name }} must be a string');
        }
{{- else if eq .PHPType.Name "int" }}
        if (!is_int(${{ .Name | toCamelCase }}) && !is_numeric(${{ .Name | toCamelCase }})) {
            throw new \InvalidArgumentException('{{ $.Name }} {{ .Name }} must be an integer');
        }
        ${{ .Name | toCamelCase }} = (int) ${{ .Name | toCamelCase }};
{{- else if eq .PHPType.Name "bool" }}
        if (!is_bool(${{ .Name | toCamelCase }})) {
            throw new \InvalidArgumentException('{{ $.Name }} {{ .Name }} must be a boolean');
        }
{{- else if .PHPType.IsArray }}
        if (!is_array(${{ .Name | toCamelCase }})) {
            throw new \InvalidArgumentException('{{ $.Name }} {{ .Name }} must be an array');
        }

        // Validate and process {{ .Name }} array
{{- if .PHPType.ArrayItemType }}
{{- if eq .PHPType.ArrayItemType.Name "string" }}
        $validated{{ .Name | toCamel }} = array_map(
            static fn(mixed ${{ .Name | singularize }}): string => is_string(${{ .Name | singularize }}) 
                ? ${{ .Name | singularize }} 
                : throw new \InvalidArgumentException('{{ .Name | toCamelCase | singularize }} must be a string'),
            ${{ .Name | toCamelCase }}
        );
{{- else if ne .PHPType.ArrayItemType.Name "mixed" }}
        $validated{{ .Name | toCamel }} = array_map(
            static fn(mixed ${{ .Name | singularize }}Data): {{ .PHPType.ArrayItemType.Name }} => is_array(${{ .Name | singularize }}Data)
                ? {{ .PHPType.ArrayItemType.Name }}::fromArray(${{ .Name | singularize }}Data)
                : throw new \InvalidArgumentException('{{ .Name | toCamelCase | singularize }} data must be an array'),
            ${{ .Name | toCamelCase }}
        );
{{- else }}
        $validated{{ .Name | toCamel }} = ${{ .Name | toCamelCase }};
{{- end }}
{{- else }}
        $validated{{ .Name | toCamel }} = ${{ .Name | toCamelCase }};
{{- end }}
{{- end }}

{{- end }}
{{- end }}

{{- /* Handle optional fields with modern processing */ -}}
{{- range .Properties }}
{{- if not .Required }}
        // Optional fields with safe processing
{{- if eq .PHPType.Name "int" }}
        ${{ .Name | toCamelCase }} = match (true) {
            !isset($data['{{ .Name }}']) => null,
            is_int($data['{{ .Name }}']) => $data['{{ .Name }}'],
            is_numeric($data['{{ .Name }}']) => (int) $data['{{ .Name }}'],
            default => null,
        };
{{- else if eq .PHPType.Name "string" }}
        ${{ .Name | toCamelCase }} = isset($data['{{ .Name }}']) && is_string($data['{{ .Name }}']) ? $data['{{ .Name }}'] : null;
{{- else if eq .PHPType.Name "bool" }}
        ${{ .Name | toCamelCase }} = isset($data['{{ .Name }}']) && is_bool($data['{{ .Name }}']) ? $data['{{ .Name }}'] : null;
{{- else if .PHPType.IsArray }}
        ${{ .Name | toCamelCase }} = isset($data['{{ .Name }}']) && is_array($data['{{ .Name }}'])
{{- if .PHPType.ArrayItemType }}
{{- if eq .PHPType.ArrayItemType.Name "string" }}
            ? array_map(
                static fn(mixed ${{ .Name | singularize }}): string => is_string(${{ .Name | singularize }}) 
                    ? ${{ .Name | singularize }} 
                    : throw new \InvalidArgumentException('{{ .Name | toCamelCase | singularize }} must be a string'),
                $data['{{ .Name }}']
            )
{{- else if ne .PHPType.ArrayItemType.Name "mixed" }}
            ? array_map(
                static fn(mixed ${{ .Name | singularize }}Data): {{ .PHPType.ArrayItemType.Name }} => is_array(${{ .Name | singularize }}Data)
                    ? {{ .PHPType.ArrayItemType.Name }}::fromArray(${{ .Name | singularize }}Data)
                    : throw new \InvalidArgumentException('{{ .Name | toCamelCase | singularize }} data must be an array'),
                $data['{{ .Name }}']
            )
{{- else }}
            ? $data['{{ .Name }}']
{{- end }}
{{- else }}
            ? $data['{{ .Name }}']
{{- end }}
            : [];
{{- else }}
        ${{ .Name | toCamelCase }} = isset($data['{{ .Name }}']) && is_array($data['{{ .Name }}'])
            ? {{ .PHPType.Name }}::fromArray($data['{{ .Name }}'])
            : null;
{{- end }}

{{- end }}
{{- end }}

        return new self(
{{- range $index, $prop := .Properties }}
            {{ $prop.Name | toCamelCase }}: {{ if and $prop.Required $prop.PHPType.IsArray }}$validated{{ $prop.Name | toCamel }}{{ else }}${{ $prop.Name | toCamelCase }}{{ end }}{{ if ne $index (sub (len $.Properties) 1) }},{{ end }}
{{- end }}
        );
    }

{{- /* Union type helper methods */ -}}
{{- if hasSpecialCase . 10 }}
{{- if .TemplateContext.UnionType }}
{{- $unionCtx := .TemplateContext.UnionType }}

    /**
     * Detect and create appropriate union type instance
     * @param array<string, mixed> $data
     * @return self
     */
    public static function fromUnionData(array $data): self
    {
{{ renderUnionTypeDetection $unionCtx | indent 8 }}
    }
{{- end }}
{{- end }}

{{- /* Enum helper methods */ -}}
{{- if .IsEnum }}

    /**
     * Get all possible enum values
     * @return array<mixed>
     */
    public static function getAllowedValues(): array
    {
        return [
{{- range .EnumValues }}
            {{ formatDefaultValue . }},
{{- end }}
        ];
    }

    /**
     * Check if value is valid enum value
     */
    public static function isValidValue(mixed $value): bool
    {
        return in_array($value, self::getAllowedValues(), true);
    }
{{- end }}

{{- /* Custom methods defined in the model */ -}}
{{- range .Methods }}

    /**
     * {{ .DocComment }}
     */
    {{ .Visibility }}{{ if .IsStatic }} static{{ end }} function {{ .Name }}(
{{- range $index, $param := .Parameters }}
        {{ formatConstructorParam $param (eq $index (sub (len $.Parameters) 1)) }}
{{- end }}
    ){{ if .ReturnType }}: {{ .ReturnType }}{{ end }}
    {
{{ .Body | indent 8 }}
    }
{{- end }}
} 