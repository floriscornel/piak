package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/floriscornel/piak/internal/types"
	"github.com/iancoleman/strcase"
)

// PHPGenerator generates PHP code from OpenAPI specifications
type PHPGenerator struct {
	config *types.GeneratorConfig
}

// NewPHPGenerator creates a new PHPGenerator instance
func NewPHPGenerator(cfg *types.GeneratorConfig) *PHPGenerator {
	return &PHPGenerator{
		config: cfg,
	}
}

// GenerateFromModel generates PHP code from the internal model
func (g *PHPGenerator) GenerateFromModel(model *types.InternalModel) error {
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(g.config.OutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	for name, schema := range model.Schemas {
		if err := g.generateClass(name, schema); err != nil {
			return fmt.Errorf("failed to generate class %s: %w", name, err)
		}
	}

	// Generate API client if requested
	if g.config.GenerateClient {
		if err := g.generateClient(model); err != nil {
			return fmt.Errorf("failed to generate API client: %w", err)
		}
	}

	return nil
}

func (g *PHPGenerator) generateClass(name string, schema *types.SchemaModel) error {
	className := strcase.ToCamel(name)
	fileName := className + g.config.PHP.FileExtension
	filePath := filepath.Join(g.config.OutputDir, fileName)

	// Check if file exists and overwrite is disabled
	if !g.config.Overwrite {
		if _, err := os.Stat(filePath); err == nil {
			fmt.Printf("⚠️  Skipping %s (file exists, overwrite disabled)\n", fileName)
			return nil
		}
	}

	content := g.generateClassContent(className, schema)

	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", filePath, err)
	}

	fmt.Printf("✅ Generated: %s\n", fileName)
	return nil
}

func (g *PHPGenerator) generateClient(model *types.InternalModel) error {
	fileName := "ApiClient" + g.config.PHP.FileExtension
	filePath := filepath.Join(g.config.OutputDir, fileName)

	content := g.generateClientContent(model)

	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write client file: %w", err)
	}

	fmt.Printf("✅ Generated API Client: %s\n", fileName)
	return nil
}

func (g *PHPGenerator) generateClassContent(className string, schema *types.SchemaModel) string {
	var content strings.Builder

	// PHP opening tag and strict types
	content.WriteString("<?php\n")
	if g.config.PHP.UseStrictTypes {
		content.WriteString("\ndeclare(strict_types=1);\n")
	}

	// Namespace
	if g.config.PHP.Namespace != "" {
		content.WriteString(fmt.Sprintf("\nnamespace %s;\n", g.config.PHP.Namespace))
	}

	// Class docblock
	if g.config.PHP.GenerateDocblocks {
		content.WriteString("\n/**\n")
		if schema.Description != "" {
			content.WriteString(fmt.Sprintf(" * %s\n", schema.Description))
		} else {
			content.WriteString(fmt.Sprintf(" * %s model\n", className))
		}
		content.WriteString(" * \n")
		content.WriteString(" * Generated by piak from OpenAPI specification\n")
		content.WriteString(" */\n")
	}

	// Class declaration
	content.WriteString(fmt.Sprintf("class %s\n{\n", className))

	// Properties
	for _, prop := range schema.Properties {
		g.generateProperty(&content, prop)
	}

	// Constructor (if there are properties)
	if len(schema.Properties) > 0 {
		g.generateConstructor(&content, schema)
	}

	// Getters and setters
	for _, prop := range schema.Properties {
		g.generateAccessors(&content, prop)
	}

	content.WriteString("}\n")

	return content.String()
}

func (g *PHPGenerator) generateClientContent(model *types.InternalModel) string {
	var content strings.Builder

	// PHP opening tag and strict types
	content.WriteString("<?php\n")
	if g.config.PHP.UseStrictTypes {
		content.WriteString("\ndeclare(strict_types=1);\n")
	}

	// Namespace
	if g.config.PHP.Namespace != "" {
		content.WriteString(fmt.Sprintf("\nnamespace %s;\n", g.config.PHP.Namespace))
	}

	// Imports based on HTTP client
	content.WriteString("\n")
	switch g.config.HTTPClient {
	case types.GuzzleClient:
		content.WriteString("use GuzzleHttp\\Client;\n")
		content.WriteString("use GuzzleHttp\\Exception\\GuzzleException;\n")
		content.WriteString("use GuzzleHttp\\RequestOptions;\n")
	case types.LaravelClient:
		content.WriteString("use Illuminate\\Http\\Client\\Factory as HttpFactory;\n")
	}

	// Class docblock
	if g.config.PHP.GenerateDocblocks {
		content.WriteString("\n/**\n")
		content.WriteString(fmt.Sprintf(" * %s API Client\n", model.Info.Title))
		content.WriteString(" * \n")
		if model.Info.Description != "" {
			content.WriteString(fmt.Sprintf(" * %s\n", model.Info.Description))
		}
		content.WriteString(fmt.Sprintf(" * Version: %s\n", model.Info.Version))
		content.WriteString(" * \n")
		content.WriteString(" * Generated by piak from OpenAPI specification\n")
		content.WriteString(" */\n")
	}

	content.WriteString("class ApiClient\n{\n")

	// Basic client structure
	switch g.config.HTTPClient {
	case types.GuzzleClient:
		content.WriteString("    private Client $client;\n")
	case types.LaravelClient:
		content.WriteString("    private HttpFactory $http;\n")
	}
	content.WriteString("    private string $baseUrl;\n")
	content.WriteString("    private array $defaultHeaders;\n\n")

	// Constructor
	content.WriteString("    public function __construct(\n")
	content.WriteString("        string $baseUrl,\n")
	content.WriteString("        array $defaultHeaders = []\n")
	content.WriteString("    ) {\n")
	content.WriteString("        $this->baseUrl = rtrim($baseUrl, '/');\n")
	content.WriteString("        $this->defaultHeaders = $defaultHeaders;\n")

	switch g.config.HTTPClient {
	case types.GuzzleClient:
		content.WriteString("        $this->client = new Client();\n")
	case types.LaravelClient:
		content.WriteString("        $this->http = app(HttpFactory::class);\n")
	}

	content.WriteString("    }\n")

	// TODO: Add endpoint methods when we have endpoint analysis
	content.WriteString("\n    // TODO: Add API endpoint methods\n")

	content.WriteString("}\n")

	return content.String()
}

func (g *PHPGenerator) generateProperty(content *strings.Builder, prop *types.Property) {
	propName := strcase.ToSnake(prop.Name)

	// Property docblock
	if g.config.PHP.GenerateDocblocks {
		content.WriteString("\n    /**\n")
		if prop.Description != "" {
			content.WriteString(fmt.Sprintf("     * %s\n", prop.Description))
		}
		content.WriteString(fmt.Sprintf("     * @var %s\n", prop.PHPType.DocComment))
		content.WriteString("     */\n")
	}

	// Property declaration
	nullable := ""
	if !prop.Required {
		nullable = "?"
	}

	content.WriteString(fmt.Sprintf("    private %s%s $%s;\n", nullable, prop.PHPType.Name, propName))
}

func (g *PHPGenerator) generateConstructor(content *strings.Builder, schema *types.SchemaModel) {
	content.WriteString("\n    public function __construct(\n")

	// Constructor parameters
	params := make([]string, 0)
	for _, prop := range schema.Properties {
		paramName := strcase.ToSnake(prop.Name)

		param := fmt.Sprintf("        %s%s $%s",
			func() string {
				if !prop.Required {
					return "?"
				}
				return ""
			}(), prop.PHPType.Name, paramName)

		if !prop.Required {
			param += " = null"
		}

		params = append(params, param)
	}

	content.WriteString(strings.Join(params, ",\n"))
	content.WriteString("\n    ) {\n")

	// Constructor body
	for _, prop := range schema.Properties {
		paramName := strcase.ToSnake(prop.Name)
		content.WriteString(fmt.Sprintf("        $this->%s = $%s;\n", paramName, paramName))
	}

	content.WriteString("    }\n")
}

func (g *PHPGenerator) generateAccessors(content *strings.Builder, prop *types.Property) {
	propName := strcase.ToSnake(prop.Name)
	methodName := strcase.ToCamel(prop.Name)

	// Getter
	returnType := prop.PHPType.Name
	if !prop.Required {
		returnType = "?" + returnType
	}

	content.WriteString(fmt.Sprintf("\n    public function get%s(): %s\n", methodName, returnType))
	content.WriteString("    {\n")
	content.WriteString(fmt.Sprintf("        return $this->%s;\n", propName))
	content.WriteString("    }\n")

	// Setter
	paramType := prop.PHPType.Name
	if !prop.Required {
		paramType = "?" + paramType
	}

	content.WriteString(fmt.Sprintf("\n    public function set%s(%s $%s): self\n", methodName, paramType, propName))
	content.WriteString("    {\n")
	content.WriteString(fmt.Sprintf("        $this->%s = $%s;\n", propName, propName))
	content.WriteString("        return $this;\n")
	content.WriteString("    }\n")
}
